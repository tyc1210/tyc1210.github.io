## Queue

类型

- Direct：直连一对一
- Fanout：广播一对所有(路由键在扇形交换机里没有作用)
- Topic ：通过路由发送到一个或多个消息队列中(*代表一个单词，#代表0或多个)
- Headers：头交换机类似与主题交换机(当”x-match”的值为“any”时，只需要消息头的任意一个值匹配成功即可，当”x-match”值为“all”时，要求消息头的所有值都需相等才可匹配成功。)

参数配置

- 参数1：消息队列的名字
- 参数2：是否持久化（重启之后是否消失）
- 参数3：是否排他，一般我们都是设置为 false
- 参数4：没有任何订阅的消费者的话是否自动删除，一般适用于临时队列。
- 参数5：hashmap类型 配置参数

排他性

​		如果设置为 true，则该消息队列只有创建它的 Connection 才能访问，其他的 Connection 都不能访问该消息队列，当连接断掉的时候，该消息队列也会自动删除（无论该队列是否被声明为持久性队列都会被删除）。

```java
// 参数5
map.put("x-message-ttl", 10000),为队列中消息设置过期时间
map.put("x-dead-letter-exchange", "交换机名称"）配置死信交换机
map.put("x-dead-letter-routing-key", "routing_key"）配置死信 routing_key
```



## 消息会过期吗？

默认情况下：消息未被消费的话就一直存在队列中

设置消费过期时间TTL

- 法1：声明队列设置有效期，所有进入此队列的消息都有相同的过期时间
- 法2：在发送消息的时候设置消息的有效期，这样不同的消息就具有不同的有效期

**注**：如果两个都设置了以时间短的为准。消息过期了就会被从队列中删除进入死信队列

第一种方式：

​		当消息队列设置过期时间的时候，那么消息过期了就会被删除，因为消息进入 RabbitMQ 后是存在一个消息队列中，队列的头部是最早要过期的消息，所以 RabbitMQ 只需要一个定时任务，从头部开始扫描是否有过期消息，有的话就直接删除。

第二种方式：

​		对于第二种方式，当消息过期后并不会立马被删除，而是当消息要投递给消费者的时候才会去删除，因为第二种方式，每条消息的过期时间都不一样，想要知道哪条消息过期，必须要遍历队列中的所有消息才能实现，当消息比较多时这样就比较耗费性能，因此对于第二种方式，当消息要投递给消费者的时候才去删除。



## 实现延时？
方案：死信队列+TTL
理解：发送消息到指定交换机和routingKey，某个队列绑定了此交换机与发送的routingKey一致。为这个队列配置过期时间死信队列相应的routingKey，这个队列没有消费者，消息过期后发送到了死信队列，死信队列的消费者消费消息实现延时功能。
也就是说：消息路由到第一个队列没有消费者过期后路由到了另一个名字为死信队列的队列(也就是普通队列而已)

## 保证消息成功发送？
1.事务(性能较低)
2.消息发送需要先发送到交换机再发送到队列，配置rabbitmq开启回调(消息到达交换机回调与消息未成功路由到队列的回调)

消息失败处理

- 方法1：配置rabbitmq重试参数；
- 方法2：将消息记录到数据库中，定时任务来实现重试

## 保证消息成功接收与防止重复消费？

默认情况下，消息消费就是自动确认的, 配置手动确认: 

```properties
spring.rabbitmq.listener.simple.acknowledge-mode=manual
```

确认消费完成

```java
//false，表示仅确认当前消息消费成功， true，表示当前消息之前所有未被当前消费者确认的消息都消费
channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
```

拒绝消息

```java
/**
* 第一个参数表示消息的 id
* 第二个参数 multiple 如果为 false，表示仅拒绝当前消息的消费，true，则表示拒绝当前消息之前所有* 未被当前消费者确认的消息；
* 第三个参数被拒绝的消息是否重新入队。(同一条消息只能拒绝一次)
*/
channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, true);
```

利用redis防止重复消费


```java
if(setnx(messageId，0)){
		//说明没有人处理过 
    	//执行消费逻辑 
    	//执行完后将redis对应key值设置为1 
    	//手动确认消息
	}else{
	   int flag = get(messageId);
	   if(0 == flag){
		//正在处理中，不调用ack
		return;
		}
	   if(1 == flag){
		//调用手动确认
		}	
	}
```

